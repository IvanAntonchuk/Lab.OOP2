# Lab.OOP3
**Виконав:** Антончук Іван  
**Група:** ІПС-21

[Документація](https://ivanantonchuk.github.io/Lab.OOP2/)
###  Юніт-тестування нового функціоналу

Для перевірки коректності роботи інтегрованих бібліотек було розроблено набір автоматичних тестів (файл `tst_linkmanagertest.cpp`):

1.  **QR-код (`testQRCodeLibrary`):** Перевіряє, що бібліотека коректно лінкується, створює об'єкт `QrCode` та генерує матрицю валідного розміру.
2.  **HTML парсинг (`testWebUtilsTitleExtraction`):** Перевіряє логіку вилучення заголовка сторінки (Regex) на різних вхідних даних, емулюючи відповідь від `httplib`.
3.  **Формати експорту (`testExportFormats`):** Перевіряє правильність формування рядків для BibTeX, Harvard та ДСТУ.
4.  **Імпорт даних (`testJsonImport`, `testImportFromCSV`):** Гарантує коректне відновлення стану програми з файлів.

## Звіт-ретроспектива до Лабораторної роботи №3

### 1. Які конкретні задачі планували вирішувати за допомогою цієї бібліотеки?
У цій роботі було використано три бібліотеки для вирішення специфічних задач, які складно або нераціонально реалізовувати з нуля:
* **QR Code generator (Project Nayuki):** Генерація матриці (логічної сітки) QR-коду на основі URL-адреси для подальшого відображення користувачу.
* **cpp-httplib (yhirose):** Виконання HTTP/HTTPS GET-запитів до вебсайтів для отримання HTML-коду сторінок (з метою автоматичного вилучення заголовка `<title>`) та завантаження файлів іконок (favicon).
* **stb_image (nothings):** Декодування завантажених з мережі зображень (фавіконок) з "сирого" байтового буфера у формат пікселів, який можна конвертувати в `QImage` для відображення в інтерфейсі.

### 2. Чому було обрано саме цю бібліотеку, а не аналоги?
* **QR Code generator:** Обрано через її легковажність та відсутність зовнішніх залежностей. На відміну від `libqrencode` або `ZXing`, вона складається лише з двох файлів і надає чисту математичну логіку генерації, не нав'язуючи конкретний спосіб малювання, що ідеально підходить для інтеграції з Qt.
* **cpp-httplib:** Це *header-only* бібліотека, яка є значно простішою в налаштуванні та використанні для простих запитів, ніж "важковаговий" стандарт `libcurl`. Вона має інтуїтивний інтерфейс, схожий на Python-бібліотеки.
* **stb_image:** Індустріальний стандарт для невеликих проектів. Вона також є *header-only*, підтримує широкий спектр форматів (PNG, JPEG, GIF тощо) і не вимагає складного лінкування, як `ImageMagick` чи `OpenCV`.

### 3. Наскільки просто та зрозуміло було отримати, встановити, налаштувати та почати використовувати цю бібліотеку?
Процес інтеграції був доволі простим завдяки архітектурі бібліотек:
* Для **stb_image** та **cpp-httplib** достатньо було просто скопіювати заголовні файли (`.h`) у папку проекту.
* Для **QR Code generator** знадобилося додати source-файли (`.cpp` та `.hpp`) до проекту.
* **Нюанс налаштування:** Єдиним складним моментом було налаштування `cpp-httplib` для роботи з HTTPS на Windows (MSVC/MinGW), що вимагало встановлення OpenSSL та явного прописування шляхів до бібліотек (`-lssl -lcrypto`) у файлі `.pro`.

### 4. Наскільки зрозумілою та корисною була документація бібліотеки?
* **QR Code generator:** Документація відмінна. Автор надає не лише опис API, а й глибоке пояснення принципів роботи QR-кодів. Приклади коду покривають всі необхідні сценарії.
* **cpp-httplib:** Файл `README.md` у репозиторії діє як "Cookbook" (книга рецептів) і містить зрозумілі приклади для більшості типів запитів.
* **stb_image:** Документація специфічна — вона знаходиться у вигляді коментарів всередині самого заголовного файлу. Це трохи незвично для навігації, але опис функцій вичерпний.

### 5. Наскільки було зрозуміло, як саме використовувати бібліотеку, які класи/методи/функції використовувати для вирішення поставлених задач?
Поріг входження виявився низьким:
* У **httplib** метод `Client::Get()` є інтуїтивно зрозумілим.
* У **stb_image** функція `stbi_load_from_memory()` чітко відповідає поставленій задачі (завантаження з буфера).
* У **QR Code generator** основний клас `QrCode` та статичний метод `encodeText` одразу дають бажаний результат.

### 6. Наскільки зручно було використовувати бібліотеку, чи не треба було писати багато надлишкового коду?
Використання бібліотек значно скоротило обсяг коду порівняно з ручною реалізацією (робота з сокетами, алгоритми Ріда-Соломона).
* Певний "boilerplate" (шаблонний код) знадобився лише для **QR Code generator**: оскільки бібліотека повертає лише логічну матрицю (0/1), довелося написати власний цикл для відмальовування квадратів через `QPainter`.

### 7. Наскільки зрозумілою була поведінка класів/методів/функцій з бібліотеки?
Поведінка була повністю передбачуваною:
* **httplib** працює синхронно, блокуючи виконання до отримання відповіді (що очікувано).
* **stb_image** коректно повертає `NULL` та звільняє пам'ять при помилках.
* **QR Code generator** стабільно генерує коректні матриці для різних рівнів корекції помилок.

### 8. Наскільки зрозумілою була взаємодія між різними класами/методами/функціями цієї бібліотеки, а також взаємодія між бібліотекою та власним кодом?
Для чистоти архітектури взаємодія з бібліотеками була інкапсульована:
* Логіка `cpp-httplib` схована у статичному класі-помічнику `WebUtils`.
* Логіка `qrcodegen` ізольована у візуальному класі `QRDialog`.
Це дозволило уникнути конфліктів типів та "забруднення" основної логіки програми (`LinkManager`) сторонніми типами даних.

### 9. Чи виникали якісь проблеми з використанням бібліотеки? Чи вдалось їх вирішити, як саме?
* **Проблема 1:** Помилка лінкувальника (`undefined reference`) при спробі запустити тести для `qrcodegen`.
    * *Рішення:* Додав файл реалізації `qrcodegen.cpp` у змінну `SOURCES` у файлі конфігурації тестів (`LinkManagerTest.pro`).
* **Проблема 2:** Неможливість виконання HTTPS запитів "з коробки".
    * *Рішення:* Встановив бібліотеки OpenSSL та налаштував лінкування у `OOP2Lab.pro`.

### 10. Що хорошого можна сказати про цю бібліотеку, які були позитивні аспекти використання бібліотеки?
* **Легковагість:** Бібліотеки мінімально збільшують розмір виконуваного файлу.
* **Портативність:** Код легко переноситься між різними операційними системами, оскільки бібліотеки не зав'язані на специфічні API ОС.
* **Простота:** Відсутність складних систем збірки (як CMake чи autotools) для інтеграції.

### 11. Що поганого можна сказати про цю бібліотеку, які були негативні аспекти використання бібліотеки?
* **cpp-httplib:** Синхронна природа бібліотеки призводить до короткочасного "зависання" інтерфейсу програми під час виконання мережевого запиту (якщо інтернет повільний).
* **stb_image:** Відсутність окремої веб-документації може бути незручною для новачків, які звикли читати мануали в браузері.

### 12. Якби довелось вирішувати аналогічну задачу, але вже враховуючи досвід використання в цій лабораторній роботі, що варто було б робити так само, а що змінити?
* **Що залишити:** Вибір бібліотек. Вони ідеально підходять для навчальних цілей та невеликих desktop-додатків.
* **Що змінити:**
    1.  Для **мережевих запитів** (`httplib`) варто реалізувати виконання у окремому потоці (використовуючи `std::thread` або `QtConcurrent`), щоб запити не блокували головний потік GUI.
    2.  Для **серіалізації** даних (JSON) можна розглянути перехід на бібліотеку `nlohmann/json` замість `QJsonDocument`, щоб зробити модуль `LinkSerializer` повністю незалежним від фреймворку Qt (Pure C++).

### Використані ресурси
1.  [QR Code generator (GitHub)](https://github.com/nayuki/QR-Code-generator)
2.  [cpp-httplib (GitHub)](https://github.com/yhirose/cpp-httplib)
3.  [stb (GitHub)](https://github.com/nothings/stb)

# Lab.OOP2
# Лабораторна робота №2 з ООП
**Варіант:** 6 (Колекція посилань на ресурси)  
**Виконав:** Антончук Іван  
**Група:** ІПС-21

Виконано всі базові та додаткові можливості, присутні unit тести за допомогою фреймворку **Qt Test**
